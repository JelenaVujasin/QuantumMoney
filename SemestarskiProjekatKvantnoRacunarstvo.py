# -*- coding: utf-8 -*-
"""Kvantno.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hc7wOQP8KdqQp_bmJOOwXi5c807XRLve
"""

!pip install qiskit
!pip install qiskit-aer
import os
from qiskit import QuantumCircuit, Aer, transpile, assemble, QuantumRegister
import random

class Emitent:
    def __init__(self, file_path='emitent_data.txt'):
        self.file_path = file_path
        self.create_file()

    def create_file(self):
        # Kreiranje datoteke ako ne postoji
        if not os.path.exists(self.file_path):
            with open(self.file_path, 'w') as file:
                file.write('')

    def generate_random_bits(self):
        # Kreiranje kvantnog kola sa dva qubita
        circuit = QuantumCircuit(2)

        # Postavljanje qubita u superpoziciju
        circuit.h(0)
        circuit.h(1)

        # Merenje qubita
        circuit.measure_all()

        # Izbor simulatora Aer qasm_simulator
        simulator = Aer.get_backend('qasm_simulator')

        # Transpilacija kvantnog kola za simulator
        compiled_circuit = transpile(circuit, simulator)

        # Izvršavanje simulacije i dobijanje rezultata
        job = assemble(compiled_circuit, shots=1024)
        result = simulator.run(job).result()
        counts = result.get_counts()

        # Konvertovanje rezultata u niz bitova
        random_bits = list(counts.keys())[0]

        return random_bits


    def create_note(self, num_qubits):
      # Kreiranje kvantnog kola za novčanicu
      qubit_states = {}

      # Dodavanje slučajnih kvantnih stanja na kubite
      for i in range(1, num_qubits + 1):
          bits = self.generate_random_bits()
          qubit_label = f'q{i}'

          match bits:
              case '00':
                  qubit_states[qubit_label] = '|0⟩'
              case '01':
                  qubit_states[qubit_label] = '|+⟩'
              case '10':
                  qubit_states[qubit_label] = '|1⟩'
              case '11':
                  qubit_states[qubit_label] = '|-⟩'

      return qubit_states

    def create_quantum_serial_number(self):
       # Kreiranje kvantnog kola za generisanje četvorocifrenog serijskog broja
      quantum_circuit = QuantumCircuit(14, 14)  # 14 bita kako bismo pokrili raspon od 0 do 16383
      quantum_circuit.h(range(14))
      quantum_circuit.measure(range(14), range(14))

      # Izbor simulatora Aer qasm_simulator
      simulator = Aer.get_backend('qasm_simulator')

      # Transpilacija kvantnog kola za simulator
      compiled_circuit = transpile(quantum_circuit, simulator)

      # Izvršavanje simulacije i dobijanje rezultata
      job = assemble(compiled_circuit, shots=1)
      result = simulator.run(job).result()
      counts = result.get_counts()

      # Konvertovanje rezultata merenja u četvorocifreni serijski broj
      serial_number = int(list(counts.keys())[0], 2) % 9000 + 1000

      return serial_number


    def issue_note(self, num_qubits):
        qubit_states = self.create_note(num_qubits)
        # Dodavanje serijskog broja novčanice
        serial_number = self.create_quantum_serial_number()
        # Čuvanje podataka o izdatoj novčanici u tekstualnoj datoteci
        with open(self.file_path, 'a') as file:
           file.write(f'\nSerial Number: {serial_number}, Quantum State: {qubit_states}\n')

        enc_qubits = encryptor.encrypt(qubit_states)

        return serial_number,enc_qubits


    def verify_note(self, serial_number, quantum_state):
        # Logika za verifikaciju novčanice
        with open(self.file_path, 'r') as file:
            for line in file:
                if f'Serial Number: {serial_number}' in line:
                    dec_qubits = encryptor.decrypt(quantum_state)
                    # Ako je serijski broj pronađen u bazi podataka, proveri kvantno stanje
                    if f'Quantum State: {dec_qubits}' in line:
                        return True
        return False

class Korisnik:
    def __init__(self, emitent):
        self.emitent = emitent
        self.novcanik = {}

    def request_note(self, num_qubits):
        s_number,qubits = self.emitent.issue_note(num_qubits)
        self.novcanik[s_number] = qubits


    def show_wallet(self):
      print(korisnik.novcanik)


    def pay_with_note(self, serial_number):
        # Korisnik želi da plati novčanicom
        if serial_number in self.novcanik:
            verified = self.emitent.verify_note(serial_number, self.novcanik[serial_number])
            if verified:
                print(f"Plaćanje uspešno. Novčanica sa serijskim brojem {serial_number} je verifikovana i uklonjena iz novčanika.")
                del self.novcanik[serial_number]
            else:
                print(f"Plaćanje nije uspešno. Novčanica sa serijskim brojem {serial_number} nije validna.")
        else:
            print(f"Plaćanje nije uspešno. Novčanica sa serijskim brojem {serial_number} nije pronađena u novčaniku.")

class Encryptor:
    def __init__(self):
        # Ključ za enkripciju
        self.encryption_key = {'|0⟩': '#', '|+⟩': '!', '|1⟩': '&', '|-⟩': '*'}

    def encrypt(self, qubits):
        # Šifrovanje kubita
        encrypted_qubits = [self.encryption_key[qubit] for qubit in qubits.values()]
        return encrypted_qubits

    def decrypt(self, encrypted_qubits):
        # Dešifrovanje kubita
        decryption_key = {v: k for k, v in self.encryption_key.items()}
        decrypted_qubits = {f'q{i+1}': decryption_key[qubit] for i, qubit in enumerate(encrypted_qubits)}
        return decrypted_qubits

import random

class Falsifikator:
    def __init__(self, emitent,encryptor):
        self.emitent = emitent
        self.encryptor = encryptor

    def generate_fake_note(self, serial_number,num_qubits):
        # Generisanje lažnog kvantnog stanja
        fake_qubits = self.emitent.create_note(num_qubits)
        en_qubits = self.encryptor.encrypt(fake_qubits)
        # Vraćanje lažne novčanice
        fake_note = {'serial_number': serial_number, 'qubits': en_qubits}
        return fake_note

    def verify_fake_note(self, fake_note):
        #print(fake_note)
        # Verifikacija lažne novčanice
        return self.emitent.verify_note(fake_note['serial_number'], fake_note['qubits'])

class KorisnickiInterfejs:
    def __init__(self, emitent, korisnik, falsifikator,file_path='emitent_data.txt'):
        self.emitent = emitent
        self.korisnik = korisnik
        self.falsifikator = falsifikator
        self.file_path = file_path
        self.encryptor = encryptor

    def pokreni(self):
        while True:
            print("\nIzaberite opciju:")
            print("1. Izdavanje novčanice")
            print("2. Pregled sadržaja baze podataka sa izdatim novčanicama")
            print("3. Verifikacija novčanice")
            print("4. Pokušaj falsifikovanja")
            print("5. Prikaz novcanika korisnika")
            print("0. Izlaz")

            opcija = input("Unesite broj opcije: ")

            if opcija == "1":
                self.izdavanje_novcanice()
            elif opcija == "2":
                self.pregled_baze_podataka()
            elif opcija == "3":
                self.verifikacija_novcanice()
            elif opcija == "4":
                self.pokusaj_falsifikovanja()
            elif opcija == "5":
                self.ispisi_novcanik()
            elif opcija == "0":
                self.clear_data()
                break
            else:
                print("Nepoznata opcija. Pokušajte ponovo.")

    def izdavanje_novcanice(self):
        num_qubits = int(input("Unesite broj kubita za novčanicu: "))
        self.korisnik.request_note(num_qubits)
        print(f"Novčanica sa {num_qubits} kubita izdata.")

    def pregled_baze_podataka(self):
        print("\nBaza podataka sa izdatim novčanicama:")
        with open(self.emitent.file_path, 'r') as file:
            for line in file:
                print(line.strip())

    def verifikacija_novcanice(self):
        serial_number = int(input("Unesite serijski broj novcanice za verifikaciju: "))
        self.korisnik.pay_with_note(serial_number)

    def pokusaj_falsifikovanja(self):
        num_qubits = int(input("Unesite broj kubita za novčanicu: "))
        fake_sn = int(input("Unesite serijski broj lazne novcanice"))
        fake_note = self.falsifikator.generate_fake_note(fake_sn,num_qubits)
        verification_result = self.falsifikator.verify_fake_note(fake_note)
        print("Pokušaj falsifikovanja:")
        print(f"Lažna novčanica: {fake_note}")
        print(f"Rezultat verifikacije: {verification_result}")

    def clear_data(self):
        # Brisanje svih podataka iz datoteke
        with open(self.file_path, 'w') as file:
            file.write('')
        print("Program je zavrsen")

    def ispisi_novcanik(self):
        print("SADRZAJ NOVCANIKA\n")
        self.korisnik.show_wallet()


emitent = Emitent()
korisnik = Korisnik(emitent)
encryptor  = Encryptor()
falsifikator = Falsifikator(emitent,encryptor)


interfejs = KorisnickiInterfejs(emitent, korisnik, falsifikator)
interfejs.pokreni()